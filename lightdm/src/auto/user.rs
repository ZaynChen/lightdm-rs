// This file was generated by gir (https://github.com/gtk-rs/gir)
// from lightdm-gir-files
// DO NOT EDIT

use crate::ffi;
use glib::{
    object::ObjectType as _,
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    /// [`User`][crate::User] is an opaque data structure and can only be accessed
    /// using the provided functions.
    ///
    /// ## Properties
    ///
    ///
    /// #### `background`
    ///  Readable
    ///
    ///
    /// #### `display-name`
    ///  Readable
    ///
    ///
    /// #### `has-messages`
    ///  Readable
    ///
    ///
    /// #### `home-directory`
    ///  Readable
    ///
    ///
    /// #### `image`
    ///  Readable
    ///
    ///
    /// #### `is-locked`
    ///  Readable
    ///
    ///
    /// #### `language`
    ///  Readable
    ///
    ///
    /// #### `layout`
    ///  Readable
    ///
    ///
    /// #### `layouts`
    ///  Readable
    ///
    ///
    /// #### `logged-in`
    ///  Readable
    ///
    ///
    /// #### `name`
    ///  Readable
    ///
    ///
    /// #### `real-name`
    ///  Readable
    ///
    ///
    /// #### `session`
    ///  Readable
    ///
    ///
    /// #### `uid`
    ///  Readable
    ///
    /// ## Signals
    ///
    ///
    /// #### `changed`
    ///  The ::changed signal gets emitted this user account is modified.
    ///
    ///
    ///
    /// # Implements
    ///
    /// [`UserExt`][trait@crate::prelude::UserExt]
    #[doc(alias = "LightDMUser")]
    pub struct User(Object<ffi::LightDMUser, ffi::LightDMUserClass>);

    match fn {
        type_ => || ffi::lightdm_user_get_type(),
    }
}

impl User {
    pub const NONE: Option<&'static User> = None;
}

/// Trait containing all [`struct@User`] methods.
///
/// # Implementors
///
/// [`User`][struct@crate::User]
pub trait UserExt: IsA<User> + 'static {
    /// Get the background file path for a user.
    ///
    /// # Returns
    ///
    /// The background file path for the given user or [`None`] if no path
    #[doc(alias = "lightdm_user_get_background")]
    #[doc(alias = "get_background")]
    fn background(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_user_get_background(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the display name of a user.
    ///
    /// # Returns
    ///
    /// The display name of the given user
    #[doc(alias = "lightdm_user_get_display_name")]
    #[doc(alias = "get_display_name")]
    #[doc(alias = "display-name")]
    fn display_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_user_get_display_name(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if a user has waiting messages.
    ///
    /// # Returns
    ///
    /// [`true`] if the user has waiting messages.
    #[doc(alias = "lightdm_user_get_has_messages")]
    #[doc(alias = "get_has_messages")]
    #[doc(alias = "has-messages")]
    fn has_messages(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_user_get_has_messages(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the home directory for a user.
    ///
    /// # Returns
    ///
    /// The users home directory
    #[doc(alias = "lightdm_user_get_home_directory")]
    #[doc(alias = "get_home_directory")]
    #[doc(alias = "home-directory")]
    fn home_directory(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_user_get_home_directory(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the image URI for a user.
    ///
    /// # Returns
    ///
    /// The image URI for the given user or [`None`] if no URI
    #[doc(alias = "lightdm_user_get_image")]
    #[doc(alias = "get_image")]
    fn image(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::lightdm_user_get_image(self.as_ref().to_glib_none().0)) }
    }

    /// Get if the user is locked.
    ///
    /// # Returns
    ///
    /// [`true`] if the user is locked
    #[doc(alias = "lightdm_user_get_is_locked")]
    #[doc(alias = "get_is_locked")]
    #[doc(alias = "is-locked")]
    fn is_locked(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_user_get_is_locked(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the language for a user.
    ///
    /// # Returns
    ///
    /// The language in the form of a local specification (e.g. "de_DE.UTF-8") for the given user or [`None`] if using the system default locale.
    #[doc(alias = "lightdm_user_get_language")]
    #[doc(alias = "get_language")]
    fn language(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_user_get_language(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the keyboard layout for a user.
    ///
    /// # Returns
    ///
    /// The keyboard layout for the given user or [`None`] if using system defaults. Copy the value if you want to use it long term.
    #[doc(alias = "lightdm_user_get_layout")]
    #[doc(alias = "get_layout")]
    fn layout(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::lightdm_user_get_layout(self.as_ref().to_glib_none().0)) }
    }

    /// Get the configured keyboard layouts for a user.
    ///
    /// # Returns
    ///
    /// A NULL-terminated array of keyboard layouts for the given user. Copy the values if you want to use them long term.
    #[doc(alias = "lightdm_user_get_layouts")]
    #[doc(alias = "get_layouts")]
    fn layouts(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::lightdm_user_get_layouts(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if a user is logged in.
    ///
    /// # Returns
    ///
    /// [`true`] if the user is currently logged in.
    #[doc(alias = "lightdm_user_get_logged_in")]
    #[doc(alias = "get_logged_in")]
    #[doc(alias = "logged-in")]
    fn is_logged_in(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_user_get_logged_in(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the name of a user.
    ///
    /// # Returns
    ///
    /// The name of the given user
    #[doc(alias = "lightdm_user_get_name")]
    #[doc(alias = "get_name")]
    fn name(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::lightdm_user_get_name(self.as_ref().to_glib_none().0)) }
    }

    /// Get the real name of a user.
    ///
    /// # Returns
    ///
    /// The real name of the given user
    #[doc(alias = "lightdm_user_get_real_name")]
    #[doc(alias = "get_real_name")]
    #[doc(alias = "real-name")]
    fn real_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_user_get_real_name(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the session for a user.
    ///
    /// # Returns
    ///
    /// The session for the given user or [`None`] if using system defaults.
    #[doc(alias = "lightdm_user_get_session")]
    #[doc(alias = "get_session")]
    fn session(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_user_get_session(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the uid of a user.
    ///
    /// # Returns
    ///
    /// The uid of the given user
    #[doc(alias = "lightdm_user_get_uid")]
    #[doc(alias = "get_uid")]
    fn uid(&self) -> u32 {
        unsafe { ffi::lightdm_user_get_uid(self.as_ref().to_glib_none().0) }
    }

    /// The ::changed signal gets emitted this user account is modified.
    #[doc(alias = "changed")]
    fn connect_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn changed_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "background")]
    fn connect_background_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_background_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::background".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_background_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "display-name")]
    fn connect_display_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_display_name_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::display-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_display_name_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "has-messages")]
    fn connect_has_messages_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_has_messages_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::has-messages".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_has_messages_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "home-directory")]
    fn connect_home_directory_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_home_directory_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::home-directory".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_home_directory_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "image")]
    fn connect_image_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_image_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::image".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_image_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "is-locked")]
    fn connect_is_locked_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_is_locked_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::is-locked".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_is_locked_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "language")]
    fn connect_language_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_language_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::language".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_language_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "layout")]
    fn connect_layout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_layout_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::layout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_layout_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "layouts")]
    fn connect_layouts_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_layouts_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::layouts".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_layouts_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "logged-in")]
    fn connect_logged_in_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_logged_in_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::logged-in".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_logged_in_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "name")]
    fn connect_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_name_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_name_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "real-name")]
    fn connect_real_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_real_name_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::real-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_real_name_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "session")]
    fn connect_session_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_session_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::session".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_session_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "uid")]
    fn connect_uid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_uid_trampoline<P: IsA<User>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(User::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::uid".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_uid_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl<O: IsA<User>> UserExt for O {}
