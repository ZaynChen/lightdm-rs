// This file was generated by gir (https://github.com/gtk-rs/gir)
// from lightdm-gir-files
// DO NOT EDIT
#![allow(deprecated)]

use crate::{MessageType, PromptType, ffi};
use glib::{
    object::ObjectType as _,
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    /// [`Greeter`][crate::Greeter] is an opaque data structure and can only be accessed
    /// using the provided functions.
    ///
    /// ## Properties
    ///
    ///
    /// #### `authentication-user`
    ///  Readable
    ///
    ///
    /// #### `autologin-guest-hint`
    ///  Readable
    ///
    ///
    /// #### `autologin-session-hint`
    ///  Readable
    ///
    ///
    /// #### `autologin-timeout-hint`
    ///  Readable
    ///
    ///
    /// #### `autologin-user-hint`
    ///  Readable
    ///
    ///
    /// #### `default-session-hint`
    ///  Readable
    ///
    ///
    /// #### `has-guest-account-hint`
    ///  Readable
    ///
    ///
    /// #### `hide-users-hint`
    ///  Readable
    ///
    ///
    /// #### `in-authentication`
    ///  Readable
    ///
    ///
    /// #### `is-authenticated`
    ///  Readable
    ///
    ///
    /// #### `lock-hint`
    ///  Readable
    ///
    ///
    /// #### `select-guest-hint`
    ///  Readable
    ///
    ///
    /// #### `select-user-hint`
    ///  Readable
    ///
    ///
    /// #### `show-manual-login-hint`
    ///  Readable
    ///
    ///
    /// #### `show-remote-login-hint`
    ///  Readable
    ///
    /// ## Signals
    ///
    ///
    /// #### `authentication-complete`
    ///  The ::authentication-complete signal gets emitted when the greeter
    /// has completed authentication.
    ///
    /// Call [`GreeterExt::is_authenticated()`][crate::prelude::GreeterExt::is_authenticated()] to check if the authentication
    /// was successful.
    ///
    ///
    ///
    ///
    /// #### `autologin-timer-expired`
    ///  The ::timed-login signal gets emitted when the automatic login timer has expired.
    /// The application should then call [`GreeterExtManual::authenticate_autologin()`][crate::prelude::GreeterExtManual::authenticate_autologin()].
    ///
    ///
    ///
    ///
    /// #### `idle`
    ///  The ::idle signal gets emitted when the user has logged in and the
    /// greeter is no longer needed.
    ///
    /// This signal only matters if the greeter has marked itself as
    /// resettable using [`GreeterExt::set_resettable()`][crate::prelude::GreeterExt::set_resettable()].
    ///
    ///
    ///
    ///
    /// #### `reset`
    ///  The ::reset signal gets emitted when the user is returning to a greeter
    /// that was previously marked idle.
    ///
    /// This signal only matters if the greeter has marked itself as
    /// resettable using [`GreeterExt::set_resettable()`][crate::prelude::GreeterExt::set_resettable()].
    ///
    ///
    ///
    ///
    /// #### `show-message`
    ///  The ::show-message signal gets emitted when the greeter
    /// should show a message to the user.
    ///
    ///
    ///
    ///
    /// #### `show-prompt`
    ///  The ::show-prompt signal gets emitted when the greeter should show a
    /// prompt to the user. The given text should be displayed and an input
    /// field for the user to provide a response.
    ///
    /// Call [`GreeterExtManual::respond()`][crate::prelude::GreeterExtManual::respond()] with the resultant input or
    /// [`GreeterExtManual::cancel_authentication()`][crate::prelude::GreeterExtManual::cancel_authentication()] to abort the authentication.
    ///
    ///
    ///
    /// # Implements
    ///
    /// [`GreeterExt`][trait@crate::prelude::GreeterExt], [`GreeterExtManual`][trait@crate::prelude::GreeterExtManual]
    #[doc(alias = "LightDMGreeter")]
    pub struct Greeter(Object<ffi::LightDMGreeter, ffi::LightDMGreeterClass>);

    match fn {
        type_ => || ffi::lightdm_greeter_get_type(),
    }
}

impl Greeter {
    pub const NONE: Option<&'static Greeter> = None;

    /// Create a new greeter.
    ///
    /// # Returns
    ///
    /// the new [`Greeter`][crate::Greeter]
    #[doc(alias = "lightdm_greeter_new")]
    pub fn new() -> Greeter {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::lightdm_greeter_new()) }
    }
}

impl Default for Greeter {
    fn default() -> Self {
        Self::new()
    }
}

/// Trait containing all [`struct@Greeter`] methods.
///
/// # Implementors
///
/// [`Greeter`][struct@crate::Greeter]
pub trait GreeterExt: IsA<Greeter> + 'static {
    /// Cancel the automatic login.
    #[doc(alias = "lightdm_greeter_cancel_autologin")]
    fn cancel_autologin(&self) {
        unsafe {
            ffi::lightdm_greeter_cancel_autologin(self.as_ref().to_glib_none().0);
        }
    }

    /// Get the user that is being authenticated.
    ///
    /// # Returns
    ///
    /// The username of the authentication user being authenticated or [`None`] if no authentication in progress.
    #[doc(alias = "lightdm_greeter_get_authentication_user")]
    #[doc(alias = "get_authentication_user")]
    #[doc(alias = "authentication-user")]
    fn authentication_user(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_greeter_get_authentication_user(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if the guest account should be automatically logged into when the timer expires.
    ///
    /// # Returns
    ///
    /// [`true`] if the guest account should be automatically logged into.
    #[doc(alias = "lightdm_greeter_get_autologin_guest_hint")]
    #[doc(alias = "get_autologin_guest_hint")]
    #[doc(alias = "autologin-guest-hint")]
    fn is_autologin_guest_hint(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_autologin_guest_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the session used to automatically log into when the timer expires.
    ///
    /// # Returns
    ///
    /// The session name or [`None`] if configured to use the default.
    #[doc(alias = "lightdm_greeter_get_autologin_session_hint")]
    #[doc(alias = "get_autologin_session_hint")]
    #[doc(alias = "autologin-session-hint")]
    fn autologin_session_hint(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_greeter_get_autologin_session_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the number of seconds to wait before automatically logging in.
    ///
    /// # Returns
    ///
    /// The number of seconds to wait before automatically logging in or 0 for no timeout.
    #[doc(alias = "lightdm_greeter_get_autologin_timeout_hint")]
    #[doc(alias = "get_autologin_timeout_hint")]
    #[doc(alias = "autologin-timeout-hint")]
    fn autologin_timeout_hint(&self) -> i32 {
        unsafe { ffi::lightdm_greeter_get_autologin_timeout_hint(self.as_ref().to_glib_none().0) }
    }

    /// Get the user account to automatically log into when the timer expires.
    ///
    /// # Returns
    ///
    /// The user account to automatically log into or [`None`] if none configured.
    #[doc(alias = "lightdm_greeter_get_autologin_user_hint")]
    #[doc(alias = "get_autologin_user_hint")]
    #[doc(alias = "autologin-user-hint")]
    fn autologin_user_hint(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_greeter_get_autologin_user_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the default session to use.
    ///
    /// # Returns
    ///
    /// The session name
    #[doc(alias = "lightdm_greeter_get_default_session_hint")]
    #[doc(alias = "get_default_session_hint")]
    #[doc(alias = "default-session-hint")]
    fn default_session_hint(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_greeter_get_default_session_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if guest sessions are supported.
    ///
    /// # Returns
    ///
    /// [`true`] if guest sessions are supported.
    #[doc(alias = "lightdm_greeter_get_has_guest_account_hint")]
    #[doc(alias = "get_has_guest_account_hint")]
    #[doc(alias = "has-guest-account-hint")]
    fn has_guest_account_hint(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_has_guest_account_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if user accounts should be shown. If this is TRUE then the list of
    /// accounts should be taken from [`UserList`][crate::UserList] and displayed in the greeter
    /// for the user to choose from. Note that this list can be empty and it is
    /// recommended you show a method for the user to enter a username manually.
    ///
    /// If this option is shown the greeter should only allow these users to be
    /// chosen for login unless the manual login hint is set.
    ///
    /// # Returns
    ///
    /// [`true`] if the available users should not be shown.
    #[doc(alias = "lightdm_greeter_get_hide_users_hint")]
    #[doc(alias = "get_hide_users_hint")]
    #[doc(alias = "hide-users-hint")]
    fn hides_users_hint(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_hide_users_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get a hint.
    /// ## `name`
    /// The hint name to query.
    ///
    /// # Returns
    ///
    /// The value for this hint or [`None`] if not set.
    #[doc(alias = "lightdm_greeter_get_hint")]
    #[doc(alias = "get_hint")]
    fn hint(&self, name: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_greeter_get_hint(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    /// Checks if the greeter is in the process of authenticating.
    ///
    /// # Returns
    ///
    /// [`true`] if the greeter is authenticating a user.
    #[doc(alias = "lightdm_greeter_get_in_authentication")]
    #[doc(alias = "get_in_authentication")]
    #[doc(alias = "in-authentication")]
    fn is_in_authentication(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_in_authentication(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Checks if the greeter has successfully authenticated.
    ///
    /// # Returns
    ///
    /// [`true`] if the greeter is authenticated for login.
    #[doc(alias = "lightdm_greeter_get_is_authenticated")]
    #[doc(alias = "get_is_authenticated")]
    #[doc(alias = "is-authenticated")]
    fn is_authenticated(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_is_authenticated(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if the greeter is acting as a lock screen.
    ///
    /// # Returns
    ///
    /// [`true`] if the greeter was triggered by locking the seat.
    #[doc(alias = "lightdm_greeter_get_lock_hint")]
    #[doc(alias = "get_lock_hint")]
    #[doc(alias = "lock-hint")]
    fn is_lock_hint(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_lock_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if the guest account should be selected by default.
    ///
    /// # Returns
    ///
    /// [`true`] if the guest account should be selected by default.
    #[doc(alias = "lightdm_greeter_get_select_guest_hint")]
    #[doc(alias = "get_select_guest_hint")]
    #[doc(alias = "select-guest-hint")]
    fn selects_guest_hint(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_select_guest_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get the user to select by default.
    ///
    /// # Returns
    ///
    /// A username or [`None`] if no particular user should be selected.
    #[doc(alias = "lightdm_greeter_get_select_user_hint")]
    #[doc(alias = "get_select_user_hint")]
    #[doc(alias = "select-user-hint")]
    fn select_user_hint(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::lightdm_greeter_get_select_user_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if a manual login option should be shown. If set the GUI
    /// should provide a way for a username to be entered manually.
    /// Without this hint a greeter which is showing a user list can
    /// limit logins to only those users.
    ///
    /// # Returns
    ///
    /// [`true`] if a manual login option should be shown.
    #[doc(alias = "lightdm_greeter_get_show_manual_login_hint")]
    #[doc(alias = "get_show_manual_login_hint")]
    #[doc(alias = "show-manual-login-hint")]
    fn shows_manual_login_hint(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_show_manual_login_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check if a remote login option should be shown. If set the GUI
    /// should provide a way for a user to log into a remote desktop server.
    ///
    /// # Returns
    ///
    /// [`true`] if a remote login option should be shown.
    #[doc(alias = "lightdm_greeter_get_show_remote_login_hint")]
    #[doc(alias = "get_show_remote_login_hint")]
    #[doc(alias = "show-remote-login-hint")]
    fn shows_remote_login_hint(&self) -> bool {
        unsafe {
            from_glib(ffi::lightdm_greeter_get_show_remote_login_hint(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Set whether the greeter will be reset instead of killed after the user logs in.
    /// This must be called before lightdm_greeter_connect is called.
    /// ## `resettable`
    /// Whether the greeter wants to be reset instead of killed after the user logs in
    #[doc(alias = "lightdm_greeter_set_resettable")]
    fn set_resettable(&self, resettable: bool) {
        unsafe {
            ffi::lightdm_greeter_set_resettable(
                self.as_ref().to_glib_none().0,
                resettable.into_glib(),
            );
        }
    }

    /// The ::authentication-complete signal gets emitted when the greeter
    /// has completed authentication.
    ///
    /// Call [`is_authenticated()`][Self::is_authenticated()] to check if the authentication
    /// was successful.
    #[doc(alias = "authentication-complete")]
    fn connect_authentication_complete<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn authentication_complete_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"authentication-complete".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    authentication_complete_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// The ::timed-login signal gets emitted when the automatic login timer has expired.
    /// The application should then call [`GreeterExtManual::authenticate_autologin()`][crate::prelude::GreeterExtManual::authenticate_autologin()].
    #[doc(alias = "autologin-timer-expired")]
    fn connect_autologin_timer_expired<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn autologin_timer_expired_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"autologin-timer-expired".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    autologin_timer_expired_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// The ::idle signal gets emitted when the user has logged in and the
    /// greeter is no longer needed.
    ///
    /// This signal only matters if the greeter has marked itself as
    /// resettable using [`set_resettable()`][Self::set_resettable()].
    #[doc(alias = "idle")]
    fn connect_idle<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn idle_trampoline<P: IsA<Greeter>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMGreeter,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"idle".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    idle_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// The ::reset signal gets emitted when the user is returning to a greeter
    /// that was previously marked idle.
    ///
    /// This signal only matters if the greeter has marked itself as
    /// resettable using [`set_resettable()`][Self::set_resettable()].
    #[doc(alias = "reset")]
    fn connect_reset<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn reset_trampoline<P: IsA<Greeter>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMGreeter,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"reset".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    reset_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// The ::show-message signal gets emitted when the greeter
    /// should show a message to the user.
    /// ## `text`
    /// Message text
    /// ## `type_`
    /// Message type
    #[doc(alias = "show-message")]
    fn connect_show_message<F: Fn(&Self, &str, MessageType) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn show_message_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P, &str, MessageType) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            text: *mut std::ffi::c_char,
            type_: ffi::LightDMMessageType,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    Greeter::from_glib_borrow(this).unsafe_cast_ref(),
                    &glib::GString::from_glib_borrow(text),
                    from_glib(type_),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"show-message".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    show_message_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// The ::show-prompt signal gets emitted when the greeter should show a
    /// prompt to the user. The given text should be displayed and an input
    /// field for the user to provide a response.
    ///
    /// Call [`GreeterExtManual::respond()`][crate::prelude::GreeterExtManual::respond()] with the resultant input or
    /// [`GreeterExtManual::cancel_authentication()`][crate::prelude::GreeterExtManual::cancel_authentication()] to abort the authentication.
    /// ## `text`
    /// Prompt text
    /// ## `type_`
    /// Prompt type
    #[doc(alias = "show-prompt")]
    fn connect_show_prompt<F: Fn(&Self, &str, PromptType) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn show_prompt_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P, &str, PromptType) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            text: *mut std::ffi::c_char,
            type_: ffi::LightDMPromptType,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    Greeter::from_glib_borrow(this).unsafe_cast_ref(),
                    &glib::GString::from_glib_borrow(text),
                    from_glib(type_),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"show-prompt".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    show_prompt_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "authentication-user")]
    fn connect_authentication_user_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_authentication_user_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::authentication-user".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_authentication_user_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "autologin-guest-hint")]
    fn connect_autologin_guest_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_autologin_guest_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autologin-guest-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autologin_guest_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "autologin-session-hint")]
    fn connect_autologin_session_hint_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_autologin_session_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autologin-session-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autologin_session_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "autologin-timeout-hint")]
    fn connect_autologin_timeout_hint_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_autologin_timeout_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autologin-timeout-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autologin_timeout_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "autologin-user-hint")]
    fn connect_autologin_user_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_autologin_user_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::autologin-user-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_autologin_user_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "default-session-hint")]
    fn connect_default_session_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_default_session_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::default-session-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_default_session_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "has-guest-account-hint")]
    fn connect_has_guest_account_hint_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_has_guest_account_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::has-guest-account-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_has_guest_account_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "hide-users-hint")]
    fn connect_hide_users_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_hide_users_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::hide-users-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_hide_users_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "in-authentication")]
    fn connect_in_authentication_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_in_authentication_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::in-authentication".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_in_authentication_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "is-authenticated")]
    fn connect_is_authenticated_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_is_authenticated_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::is-authenticated".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_is_authenticated_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "lock-hint")]
    fn connect_lock_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_lock_hint_trampoline<P: IsA<Greeter>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::lock-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_lock_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "select-guest-hint")]
    fn connect_select_guest_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_select_guest_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::select-guest-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_select_guest_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "select-user-hint")]
    fn connect_select_user_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_select_user_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::select-user-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_select_user_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "show-manual-login-hint")]
    fn connect_show_manual_login_hint_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_show_manual_login_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::show-manual-login-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_show_manual_login_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "show-remote-login-hint")]
    fn connect_show_remote_login_hint_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_show_remote_login_hint_trampoline<
            P: IsA<Greeter>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::LightDMGreeter,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(Greeter::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::show-remote-login-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_show_remote_login_hint_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl<O: IsA<Greeter>> GreeterExt for O {}
