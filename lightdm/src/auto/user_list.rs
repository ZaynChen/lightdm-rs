// This file was generated by gir (https://github.com/gtk-rs/gir)
// from lightdm-gir-files
// DO NOT EDIT

use crate::{User, ffi};
use glib::{
    object::ObjectType as _,
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    /// [`UserList`][crate::UserList] is an opaque data structure and can only be accessed
    /// using the provided functions.
    ///
    /// ## Properties
    ///
    ///
    /// #### `length`
    ///  Readable
    ///
    ///
    /// #### `num-users`
    ///  Readable
    ///
    /// ## Signals
    ///
    ///
    /// #### `user-added`
    ///  The ::user-added signal gets emitted when a user account is created.
    ///
    ///
    ///
    ///
    /// #### `user-changed`
    ///  The ::user-changed signal gets emitted when a user account is modified.
    ///
    ///
    ///
    ///
    /// #### `user-removed`
    ///  The ::user-removed signal gets emitted when a user account is removed.
    ///
    ///
    ///
    /// # Implements
    ///
    /// [`UserListExt`][trait@crate::prelude::UserListExt]
    #[doc(alias = "LightDMUserList")]
    pub struct UserList(Object<ffi::LightDMUserList, ffi::LightDMUserListClass>);

    match fn {
        type_ => || ffi::lightdm_user_list_get_type(),
    }
}

impl UserList {
    pub const NONE: Option<&'static UserList> = None;

    /// Get the user list.
    ///
    /// # Returns
    ///
    /// the [`UserList`][crate::UserList]
    #[doc(alias = "lightdm_user_list_get_instance")]
    #[doc(alias = "get_instance")]
    pub fn instance() -> Option<UserList> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::lightdm_user_list_get_instance()) }
    }
}

/// Trait containing all [`struct@UserList`] methods.
///
/// # Implementors
///
/// [`UserList`][struct@crate::UserList]
pub trait UserListExt: IsA<UserList> + 'static {
    ///
    /// # Returns
    ///
    /// The number of users able to log in
    #[doc(alias = "lightdm_user_list_get_length")]
    #[doc(alias = "get_length")]
    fn length(&self) -> i32 {
        unsafe { ffi::lightdm_user_list_get_length(self.as_ref().to_glib_none().0) }
    }

    /// Get information about a given user or [`None`] if this user doesn't exist.
    /// ## `username`
    /// Name of user to get.
    ///
    /// # Returns
    ///
    /// A [`User`][crate::User] entry for the given user.
    #[doc(alias = "lightdm_user_list_get_user_by_name")]
    #[doc(alias = "get_user_by_name")]
    fn user_by_name(&self, username: &str) -> Option<User> {
        unsafe {
            from_glib_none(ffi::lightdm_user_list_get_user_by_name(
                self.as_ref().to_glib_none().0,
                username.to_glib_none().0,
            ))
        }
    }

    /// Get a list of users to present to the user. This list may be a subset of the
    /// available users and may be empty depending on the server configuration.
    ///
    /// # Returns
    ///
    /// A list of [`User`][crate::User] that should be presented to the user.
    #[doc(alias = "lightdm_user_list_get_users")]
    #[doc(alias = "get_users")]
    fn users(&self) -> Vec<User> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::lightdm_user_list_get_users(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "num-users")]
    fn num_users(&self) -> i32 {
        ObjectExt::property(self.as_ref(), "num-users")
    }

    /// The ::user-added signal gets emitted when a user account is created.
    /// ## `user`
    /// The [`User`][crate::User] that has been added.
    #[doc(alias = "user-added")]
    fn connect_user_added<F: Fn(&Self, &User) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn user_added_trampoline<P: IsA<UserList>, F: Fn(&P, &User) + 'static>(
            this: *mut ffi::LightDMUserList,
            user: *mut ffi::LightDMUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    UserList::from_glib_borrow(this).unsafe_cast_ref(),
                    &from_glib_borrow(user),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"user-added".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    user_added_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// The ::user-changed signal gets emitted when a user account is modified.
    /// ## `user`
    /// The [`User`][crate::User] that has been changed.
    #[doc(alias = "user-changed")]
    fn connect_user_changed<F: Fn(&Self, &User) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn user_changed_trampoline<
            P: IsA<UserList>,
            F: Fn(&P, &User) + 'static,
        >(
            this: *mut ffi::LightDMUserList,
            user: *mut ffi::LightDMUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    UserList::from_glib_borrow(this).unsafe_cast_ref(),
                    &from_glib_borrow(user),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"user-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    user_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// The ::user-removed signal gets emitted when a user account is removed.
    /// ## `user`
    /// The [`User`][crate::User] that has been removed.
    #[doc(alias = "user-removed")]
    fn connect_user_removed<F: Fn(&Self, &User) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn user_removed_trampoline<
            P: IsA<UserList>,
            F: Fn(&P, &User) + 'static,
        >(
            this: *mut ffi::LightDMUserList,
            user: *mut ffi::LightDMUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    UserList::from_glib_borrow(this).unsafe_cast_ref(),
                    &from_glib_borrow(user),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"user-removed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    user_removed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "length")]
    fn connect_length_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_length_trampoline<P: IsA<UserList>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUserList,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(UserList::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::length".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_length_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "num-users")]
    fn connect_num_users_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_num_users_trampoline<P: IsA<UserList>, F: Fn(&P) + 'static>(
            this: *mut ffi::LightDMUserList,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(UserList::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::num-users".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_num_users_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl<O: IsA<UserList>> UserListExt for O {}
