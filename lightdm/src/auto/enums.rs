// This file was generated by gir (https://github.com/gtk-rs/gir)
// from lightdm-gir-files
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

/// Error codes returned by greeter operations.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "LightDMGreeterError")]
pub enum GreeterError {
    /// error communicating with daemon.
    #[doc(alias = "LIGHTDM_GREETER_ERROR_COMMUNICATION_ERROR")]
    CommunicationError,
    /// failed to connect to the daemon.
    #[doc(alias = "LIGHTDM_GREETER_ERROR_CONNECTION_FAILED")]
    ConnectionFailed,
    /// requested session failed to start.
    #[doc(alias = "LIGHTDM_GREETER_ERROR_SESSION_FAILED")]
    SessionFailed,
    /// autologin not configured.
    #[doc(alias = "LIGHTDM_GREETER_ERROR_NO_AUTOLOGIN")]
    NoAutologin,
    /// autologin not configured.
    #[doc(alias = "LIGHTDM_GREETER_ERROR_INVALID_USER")]
    InvalidUser,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GreeterError {
    type GlibType = ffi::LightDMGreeterError;

    #[inline]
    fn into_glib(self) -> ffi::LightDMGreeterError {
        match self {
            Self::CommunicationError => ffi::LIGHTDM_GREETER_ERROR_COMMUNICATION_ERROR,
            Self::ConnectionFailed => ffi::LIGHTDM_GREETER_ERROR_CONNECTION_FAILED,
            Self::SessionFailed => ffi::LIGHTDM_GREETER_ERROR_SESSION_FAILED,
            Self::NoAutologin => ffi::LIGHTDM_GREETER_ERROR_NO_AUTOLOGIN,
            Self::InvalidUser => ffi::LIGHTDM_GREETER_ERROR_INVALID_USER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::LightDMGreeterError> for GreeterError {
    #[inline]
    unsafe fn from_glib(value: ffi::LightDMGreeterError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::LIGHTDM_GREETER_ERROR_COMMUNICATION_ERROR => Self::CommunicationError,
            ffi::LIGHTDM_GREETER_ERROR_CONNECTION_FAILED => Self::ConnectionFailed,
            ffi::LIGHTDM_GREETER_ERROR_SESSION_FAILED => Self::SessionFailed,
            ffi::LIGHTDM_GREETER_ERROR_NO_AUTOLOGIN => Self::NoAutologin,
            ffi::LIGHTDM_GREETER_ERROR_INVALID_USER => Self::InvalidUser,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for GreeterError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::lightdm_greeter_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for GreeterError {
    #[inline]
    #[doc(alias = "lightdm_greeter_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::lightdm_greeter_error_get_type()) }
    }
}

impl glib::HasParamSpec for GreeterError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for GreeterError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GreeterError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for GreeterError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<GreeterError> for glib::Value {
    #[inline]
    fn from(v: GreeterError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "LightDMMessageType")]
pub enum MessageType {
    /// Informational message.
    #[doc(alias = "LIGHTDM_MESSAGE_TYPE_INFO")]
    Info,
    /// Error message.
    #[doc(alias = "LIGHTDM_MESSAGE_TYPE_ERROR")]
    Error,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MessageType {
    type GlibType = ffi::LightDMMessageType;

    #[inline]
    fn into_glib(self) -> ffi::LightDMMessageType {
        match self {
            Self::Info => ffi::LIGHTDM_MESSAGE_TYPE_INFO,
            Self::Error => ffi::LIGHTDM_MESSAGE_TYPE_ERROR,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::LightDMMessageType> for MessageType {
    #[inline]
    unsafe fn from_glib(value: ffi::LightDMMessageType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::LIGHTDM_MESSAGE_TYPE_INFO => Self::Info,
            ffi::LIGHTDM_MESSAGE_TYPE_ERROR => Self::Error,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MessageType {
    #[inline]
    #[doc(alias = "lightdm_message_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::lightdm_message_type_get_type()) }
    }
}

impl glib::HasParamSpec for MessageType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MessageType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MessageType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for MessageType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MessageType> for glib::Value {
    #[inline]
    fn from(v: MessageType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Prompt types the client is required to display.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "LightDMPromptType")]
pub enum PromptType {
    /// prompt is a question. The information can be shown as it is entered.
    #[doc(alias = "LIGHTDM_PROMPT_TYPE_QUESTION")]
    Question,
    /// prompt is for secret information. The entered information should be obscured so it can't be publically visible.
    #[doc(alias = "LIGHTDM_PROMPT_TYPE_SECRET")]
    Secret,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PromptType {
    type GlibType = ffi::LightDMPromptType;

    #[inline]
    fn into_glib(self) -> ffi::LightDMPromptType {
        match self {
            Self::Question => ffi::LIGHTDM_PROMPT_TYPE_QUESTION,
            Self::Secret => ffi::LIGHTDM_PROMPT_TYPE_SECRET,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::LightDMPromptType> for PromptType {
    #[inline]
    unsafe fn from_glib(value: ffi::LightDMPromptType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::LIGHTDM_PROMPT_TYPE_QUESTION => Self::Question,
            ffi::LIGHTDM_PROMPT_TYPE_SECRET => Self::Secret,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PromptType {
    #[inline]
    #[doc(alias = "lightdm_prompt_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::lightdm_prompt_type_get_type()) }
    }
}

impl glib::HasParamSpec for PromptType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PromptType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PromptType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for PromptType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PromptType> for glib::Value {
    #[inline]
    fn from(v: PromptType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
